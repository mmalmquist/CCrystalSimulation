#include "CrystalControl.h"

#include <stdlib.h>
#include <pthread.h>
#include <inttypes.h>
#include <time.h>
#include <string.h>
#include <stdbool.h>

#include "root_directory.h" // This is a configuration file generated by CMake.

#define DEFAULT_SPEED 10

struct crystal_control_t
{
  uint32_t number;
  CrystalModel *m_cm;
  CrystalView *m_cv;

  GtkWidget *main_app_window;
  
  volatile bool sim_running;
  pthread_t m_thread;
};

static uint32_t
CrystalControl_request_new_modifier(CrystalControl *self);
static void
signal_stop_simulation(CrystalControl *self);
static void *
run_thread(void *arg);
static gboolean
run_some_steps(gpointer data);

static double
get_time() {
  struct timespec t;
  clock_gettime(CLOCK_REALTIME, &t);
  return t.tv_sec + t.tv_nsec/1e9;
}

CrystalControl *
CrystalControl_create(CrystalModel *cm,
		      CrystalView *cv)
{
  CrystalControl *cc = (CrystalControl *)calloc(1, sizeof(CrystalControl));
  cc->m_cm = cm;
  cc->m_cv = cv;

  cc->number = DEFAULT_SPEED;
  return cc;
}

void
CrystalControl_destroy(CrystalControl *self)
{
  if (!self) { return; }
  
  signal_stop_simulation(self);
  CrystalView_destroy(self->m_cv);
  CrystalModel_destroy(self->m_cm);

  free(self);
}

static void
show_error_message(GtkWindow *parent, char const *msg)
{
  GtkWidget *dialog = gtk_message_dialog_new(parent,
					     GTK_DIALOG_DESTROY_WITH_PARENT,
					     GTK_MESSAGE_WARNING,
					     GTK_BUTTONS_OK,
					     msg, NULL);
  gtk_dialog_run(GTK_DIALOG(dialog));
  gtk_widget_destroy(dialog);
}

static uint32_t
CrystalControl_request_new_modifier(CrystalControl *self)
{
  GtkDialogFlags flags = GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT;
  GtkWidget *dialog = gtk_dialog_new_with_buttons("Change Speed",
						  GTK_WINDOW(self->main_app_window),
						  flags,
						  ("OK"), GTK_RESPONSE_ACCEPT,
						  ("Cancel"), GTK_RESPONSE_REJECT,
						  NULL);
  GtkWidget *dialog_content = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
  GtkWidget *new_mod_tf = gtk_entry_new();
  gtk_entry_set_input_purpose(GTK_ENTRY(new_mod_tf), GTK_INPUT_PURPOSE_DIGITS);
  gtk_box_pack_start(GTK_BOX(dialog_content),
		     gtk_label_new("Enter a new speed:"),
		     FALSE, FALSE, 0);
  gtk_box_pack_start(GTK_BOX(dialog_content),
		     new_mod_tf,
		     FALSE, FALSE, 0);

  gtk_container_add(GTK_CONTAINER(gtk_dialog_get_content_area(GTK_DIALOG(dialog))),
		    dialog_content);
  gtk_widget_show_all(dialog);
  
  int new_speed = -1;
  for (bool input_accepted = false; !input_accepted;) {
    int result = gtk_dialog_run(GTK_DIALOG(dialog));
    if (result == GTK_RESPONSE_ACCEPT) {
      if (gtk_entry_get_text_length(GTK_ENTRY(new_mod_tf)) > 0) {
	int _new_speed = atoll(gtk_entry_get_text(GTK_ENTRY(new_mod_tf)));
	if (_new_speed > 0) {
	  new_speed = _new_speed;
	  input_accepted = true;
	} else {
	  show_error_message(GTK_WINDOW(self->main_app_window),
			     "New value must a positive integer.");
	  gtk_entry_set_text(GTK_ENTRY(new_mod_tf), "");
	}
      }
    } else {
      input_accepted = true;
    }
  }
  gtk_widget_destroy(dialog);
  return new_speed;
}

static void
signal_stop_simulation(CrystalControl *self)
{
  if (self->sim_running) {
    self->sim_running = false;
  }
  pthread_join(self->m_thread, NULL);
}

static void *
run_thread(void *arg)
{
  CrystalControl *self = (CrystalControl *)arg;
  double t0 = get_time();
  while (self->sim_running) {
    if (!CrystalModel_run_some_steps(self->m_cm, self->number)) {
      self->sim_running = false;
    }
    g_timeout_add(0, run_some_steps, self);
  }
  double t1 = get_time();
  printf("C Simulation took %.3f s\n", t1-t0);
  return NULL;
}

static gboolean
run_some_steps(gpointer data)
{
  CrystalView_repaint(((CrystalControl *)data)->m_cv);
  return FALSE; // run once
}

static gboolean
change_speed_event_cb(GtkWidget *widget,
		      GdkEventMotion *event,
		      gpointer data)
{
  (void)widget;(void)event;
  if (!data) { return FALSE; }
  
  CrystalControl *self = (CrystalControl *) data;
  signal_stop_simulation(self);
  
  int modifier = CrystalControl_request_new_modifier(self);
  if (modifier > 0) {
    self->number = modifier;
  }
  return TRUE;
}

static gboolean
start_event_cb(GtkWidget *widget,
	       GdkEventMotion *event,
	       gpointer data)
{
  (void)widget;(void)event;
  if (!data) { return FALSE; }
  
  CrystalControl *self = (CrystalControl *) data;
  signal_stop_simulation(self);
  
  CrystalModel_reset(self->m_cm);
  CrystalView_repaint(self->m_cv);
  
  if (!self->sim_running) {
    //CrystalModel_srand(self->m_cm, time(NULL));
    CrystalModel_srand(self->m_cm, 0);
    self->sim_running = true;
    pthread_create(&self->m_thread, NULL, run_thread, self);
  }
  return TRUE;
}


static gboolean
stop_event_cb(GtkWidget *widget,
	      GdkEventMotion *event,
	      gpointer data)
{
  (void)widget;(void)event;
  if (!data) { return FALSE; }
  
  signal_stop_simulation((CrystalControl *)data);
  return TRUE;
}

void
CrystalControl_init_ui(CrystalControl *self,
		       GtkBuilder *builder)
{
  CrystalView_set_gtk_widget(self->m_cv, GTK_WIDGET(gtk_builder_get_object(builder, "bath")));
  
  GtkWidget *start_btn = GTK_WIDGET(gtk_builder_get_object(builder, "start_btn"));
  g_signal_connect(start_btn, "clicked", G_CALLBACK(start_event_cb), self);
  GtkWidget *stop_btn = GTK_WIDGET(gtk_builder_get_object(builder, "stop_btn"));
  g_signal_connect(stop_btn, "clicked", G_CALLBACK(stop_event_cb), self);
  GtkWidget *change_speed_btn = GTK_WIDGET(gtk_builder_get_object(builder, "chspeed_btn"));
  g_signal_connect(change_speed_btn, "clicked", G_CALLBACK(change_speed_event_cb), self);

  self->main_app_window = GTK_WIDGET(gtk_builder_get_object(builder, "app-window"));
}
